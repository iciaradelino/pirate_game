=== ./game_state.c ===
#include "game_state.h"
#include "room.h" // For init_rooms()

void init_game_state(GameState* gs) {
    // Initialize player state
    gs->player.current_room_id = ROOM_DECK; // Initial room (will be set after intro)
    gs->player.inventory_count = 0;
    for(int i = 0; i < MAX_INVENTORY_ITEMS; ++i) { // Clear inventory explicitly
        gs->player.inventory[i] = ITEM_NONE;
    }


    // Initialize game flags
    gs->game_over = 0;
    gs->game_won = 0;
    gs->should_restart = 0;

    // Initialize puzzle/event flags
    gs->cook_pleased = 0;
    gs->prisoners_hostile = 1;
    gs->prisoners_pacified = 0;
    for (int i = 0; i < 3; ++i) {
        gs->riddle_attempts[i] = 3;
    }
    gs->current_riddle_idx = 0;
    gs->diary_deciphered = 0;
    gs->knows_chest_code = 0;
    gs->chest_unlocked = 0;

    // Initialize special prompt state
    gs->special_prompt_active = 0;
    gs->special_prompt_context[0] = '\0';

    // Re-initialize rooms (clears items, resets visited status)
    // This is crucial for game restarts.
    init_rooms();
}

=== ./game_logic.c ===
#include "game_logic.h"
#include "item.h"
#include "room.h"
#include "player.h"
#include "utils.h"
#include "animation.h" // For run_animation in restart_game_flow
#include "game_state.h"
#include "parser.h"

#include <stdio.h> // For sprintf
#include <string.h>
#include <stdlib.h> // For rand, srand
#include <time.h>   // For time

// --- Room Description ---
void show_room_description(GameState* gs) {
    Room* current_room = &game_rooms[gs->player.current_room_id];
    char buffer[MAX_LINE_LENGTH * 2]; // Increased buffer size

    sprintf(buffer, "\n--- %s ---", current_room->name);
    log_action(gs, "INFO", buffer);

    if (!current_room->visited || gs->player.current_room_id == ROOM_DECK) { // Always full desc for deck on new entry
        log_action(gs, "INFO", current_room->description);
        current_room->visited = 1;
    } else {
        sprintf(buffer, "You are back in the %s.", current_room->name);
        log_action(gs, "INFO", buffer);
    }

    // List items in room
    int items_listed = 0;
    strcpy(buffer, "You see: ");
    for (int i = 0; i < current_room->item_count; ++i) {
        Item* item = &game_items[current_room->items_in_room[i]];
        if (item->id != ITEM_NONE) {
            if (items_listed > 0) strcat(buffer, ", ");
            strcat(buffer, "["); // Add brackets for clarity
            strcat(buffer, item->name);
            strcat(buffer, "]");
            items_listed++;
        }
    }
    if (items_listed > 0) {
        log_action(gs, "INFO", buffer);
    } else {
        log_action(gs, "INFO", "The room is empty of notable items.");
    }

    // List exits
    strcpy(buffer, "Exits: ");
    int exits_listed = 0;
    if (current_room->exits[0] != NUM_ROOMS) { strcat(buffer, "North "); exits_listed++; }
    if (current_room->exits[1] != NUM_ROOMS) { strcat(buffer, "South "); exits_listed++; }
    if (current_room->exits[2] != NUM_ROOMS) { strcat(buffer, "East ");  exits_listed++; }
    if (current_room->exits[3] != NUM_ROOMS) { strcat(buffer, "West ");  exits_listed++; }
    if (exits_listed > 0) {
        log_action(gs, "INFO", buffer);
    } else {
        log_action(gs, "INFO", "There are no obvious exits.");
    }
}

// --- Game Over / Win ---
void handle_game_over(GameState* gs, const char* message, const char* art_key) {
    log_action(gs, "GAME_EVENT", message);
    if (art_key) display_ascii_art(art_key);
    gs->game_over = 1;
    gs->should_restart = 1;
}

void handle_win_game(GameState* gs) {
    log_action(gs, "GAME_EVENT", "YOU HAVE FOUND THE TREASURE!");
    display_ascii_art("WIN_GAME");
    gs->game_won = 1;
}

// --- Movement ---
void handle_move(GameState* gs, const char* direction_str) {
    Room* current_room = &game_rooms[gs->player.current_room_id];
    RoomID next_room_id = NUM_ROOMS;
    int dir_idx = -1;

    if (strcmp(direction_str, "north") == 0) dir_idx = 0;
    else if (strcmp(direction_str, "south") == 0) dir_idx = 1;
    else if (strcmp(direction_str, "east") == 0) dir_idx = 2;
    else if (strcmp(direction_str, "west") == 0) dir_idx = 3;

    if (dir_idx != -1) {
        next_room_id = current_room->exits[dir_idx];
    }

    if (next_room_id != NUM_ROOMS) {
        // Pre-entry checks
        if (next_room_id == ROOM_CAPTAIN_QUARTERS && !gs->cook_pleased && gs->player.current_room_id == ROOM_GALLEY) {
            log_action(gs, "GAME_INFO", "The Cook blocks your path north. 'Not until ye fetch me ingredients, matey!'");
            return;
        }
        if (next_room_id == ROOM_CAPTAIN_QUARTERS && player_has_item(&gs->player, ITEM_PARROT)) {
            handle_game_over(gs, "The parrot suddenly squawks loudly, 'Intruder! Intruder!' The sleeping Captain jolts awake and shoots you!", "GAME_OVER_CAPTAIN");
            return;
        }
        if (next_room_id == ROOM_TREASURE_ROOM && !player_has_item(&gs->player, ITEM_TREASURE_KEY)) {
            log_action(gs, "GAME_INFO", "The massive door to the treasure room is sealed with an intricate lock. It won't budge.");
            return;
        }
        if (next_room_id == ROOM_TREASURE_ROOM && player_has_item(&gs->player, ITEM_TREASURE_KEY)) {
            log_action(gs, "GAME_INFO", "You use the Treasure Key. With a satisfying thunk, the heavy door unlatches!");
        }

        gs->player.current_room_id = next_room_id;
        // game_rooms[next_room_id].visited = 0; // Reset visited if you want full description always on entry
        show_room_description(gs);

        // Post-entry events
        if (next_room_id == ROOM_TREASURE_ROOM) {
            handle_win_game(gs);
        } else if (next_room_id == ROOM_PRISON_HOLD && gs->prisoners_hostile && !gs->prisoners_pacified) {
            log_action(gs, "GAME_EVENT", "You open the door to a dark, damp hold. Three shadowy Prisoners lunge at you with makeshift shivs!");
            log_action(gs, "PROMPT", "The prisoners are about to attack! What do you do? > ");
            gs->special_prompt_active = 1;
            strcpy(gs->special_prompt_context, "PRISONER_ATTACK");
        }
    } else {
        log_action(gs, "GAME_ERROR", "You can't go that way.");
    }
}

// --- Item Interaction ---
void handle_examine(GameState* gs, const char* item_name_str) {
    if (item_name_str == NULL) {
        show_room_description(gs);
        return;
    }

    Item* item_to_examine = NULL;
    Room* current_room = &game_rooms[gs->player.current_room_id];

    // Check room items first
    for (int i = 0; i < current_room->item_count; ++i) {
        ItemID current_item_id = current_room->items_in_room[i];
        if (strcasecmp(game_items[current_item_id].name, item_name_str) == 0) {
            item_to_examine = &game_items[current_item_id];
            break;
        }
    }
    // If not in room, check inventory
    if (!item_to_examine) {
        for (int i = 0; i < gs->player.inventory_count; ++i) {
            ItemID current_item_id = gs->player.inventory[i];
            if (strcasecmp(game_items[current_item_id].name, item_name_str) == 0) {
                item_to_examine = &game_items[current_item_id];
                break;
            }
        }
    }

    if (item_to_examine) {
        log_action(gs, "EXAMINE", item_to_examine->examine_text);
    } else {
        char buffer[MAX_LINE_LENGTH];
        sprintf(buffer, "You don't see any '%s' here to examine.", item_name_str);
        log_action(gs, "GAME_ERROR", buffer);
    }
}

void handle_pickup(GameState* gs, const char* item_name_str) {
    if (!item_name_str) {
        log_action(gs, "GAME_ERROR", "Pick up what?");
        return;
    }

    Room* current_room = &game_rooms[gs->player.current_room_id];
    ItemID item_id_to_pickup = ITEM_NONE;

    for (int i = 0; i < current_room->item_count; ++i) {
        if (strcasecmp(game_items[current_room->items_in_room[i]].name, item_name_str) == 0) {
            item_id_to_pickup = current_room->items_in_room[i];
            break;
        }
    }

    if (item_id_to_pickup != ITEM_NONE) {
        Item* item_ptr = &game_items[item_id_to_pickup];
        if (item_ptr->can_pickup) {
            if (gs->player.inventory_count < MAX_INVENTORY_ITEMS) {
                add_item_to_inventory(&gs->player, item_id_to_pickup);
                remove_item_from_room(current_room, item_id_to_pickup);
                char buffer[MAX_LINE_LENGTH];
                sprintf(buffer, "You picked up the %s.", item_ptr->name);
                log_action(gs, "ACTION", buffer);
            } else {
                log_action(gs, "GAME_ERROR", "Your inventory is full.");
            }
        } else {
            char buffer[MAX_LINE_LENGTH];
            sprintf(buffer, "You can't pick up the %s.", item_ptr->name);
            log_action(gs, "GAME_ERROR", buffer);
        }
    } else {
        char buffer[MAX_LINE_LENGTH];
        sprintf(buffer, "You don't see any '%s' here to pick up.", item_name_str);
        log_action(gs, "GAME_ERROR", buffer);
    }
}

void handle_drop(GameState* gs, const char* item_name_str) {
    if (!item_name_str) {
        log_action(gs, "GAME_ERROR", "Drop what?");
        return;
    }
    ItemID item_id_to_drop = ITEM_NONE;

    for (int i = 0; i < gs->player.inventory_count; ++i) {
        if (strcasecmp(game_items[gs->player.inventory[i]].name, item_name_str) == 0) {
            item_id_to_drop = gs->player.inventory[i];
            break;
        }
    }

    if (item_id_to_drop != ITEM_NONE) {
        Room* current_room = &game_rooms[gs->player.current_room_id];
        if (current_room->item_count < MAX_ROOM_ITEMS) {
            add_item_to_room(current_room, item_id_to_drop);
            remove_item_from_inventory(&gs->player, item_id_to_drop);
            char buffer[MAX_LINE_LENGTH];
            sprintf(buffer, "You dropped the %s.", game_items[item_id_to_drop].name);
            log_action(gs, "ACTION", buffer);
        } else {
            log_action(gs, "GAME_ERROR", "There's no space to drop that here.");
        }
    } else {
        char buffer[MAX_LINE_LENGTH];
        sprintf(buffer, "You don't have any '%s' to drop.", item_name_str);
        log_action(gs, "GAME_ERROR", buffer);
    }
}

void handle_inventory(GameState* gs) {
    if (gs->player.inventory_count == 0) {
        log_action(gs, "INFO", "Your inventory is empty.");
        return;
    }
    char buffer[MAX_LINE_LENGTH * 2] = "You are carrying: "; // Increased buffer
    for (int i = 0; i < gs->player.inventory_count; ++i) {
        strcat(buffer, "[");
        strcat(buffer, game_items[gs->player.inventory[i]].name);
        strcat(buffer, "]");
        if (i < gs->player.inventory_count - 1) {
            strcat(buffer, ", ");
        }
    }
    log_action(gs, "INFO", buffer);
}

// --- Specific 'use' handlers ---
void handle_use_cook(GameState* gs) {
    if (gs->player.current_room_id != ROOM_GALLEY) {
        log_action(gs, "GAME_ERROR", "The cook isn't here."); return;
    }
    if (gs->cook_pleased) {
        log_action(gs, "GAME_INFO", "The cook nods. 'The stew was fine. Go on about yer business.'"); return;
    }
    if (player_has_item(&gs->player, ITEM_SALTED_PORK) &&
        player_has_item(&gs->player, ITEM_HARDTACK_BISCUITS) &&
        player_has_item(&gs->player, ITEM_GROG_BOTTLE)) {
        log_action(gs, "GAME_EVENT", "You give the Salted Pork, Hardtack Biscuits, and Grog Bottle to the Cook.");
        log_action(gs, "GAME_EVENT", "Cook: 'Hah! Not entirely useless, are ye? Right then, the Captain's stew it is! You can pass north now.'");
        gs->cook_pleased = 1;
        remove_item_from_inventory(&gs->player, ITEM_SALTED_PORK);
        remove_item_from_inventory(&gs->player, ITEM_HARDTACK_BISCUITS);
        remove_item_from_inventory(&gs->player, ITEM_GROG_BOTTLE);
    } else {
        log_action(gs, "GAME_EVENT", "Cook: 'That's not what I asked for, ya scallywag! Trying to poison the Captain, are ye?!'");
        handle_game_over(gs, "The Cook draws a cleaver and ends your adventure.", "GAME_OVER_COOK");
    }
}

void handle_use_sword_for_prisoners(GameState* gs) {
    if (!player_has_item(&gs->player, ITEM_SWORD)) {
        log_action(gs, "GAME_ERROR", "You fumble for a sword you don't have!"); // Should not happen if logic is right
        handle_game_over(gs, "Without a weapon to defend yourself, the prisoners overwhelm you.", "GAME_OVER_PRISONERS");
        return;
    }
    log_action(gs, "ACTION", "You draw your sword, its polished steel gleaming in the dim light.");
    log_action(gs, "GAME_EVENT", "The prisoners halt, eyes wide with fear. 'Alright, alright! We yield! No need for bloodshed!'");
    gs->prisoners_pacified = 1;
    gs->prisoners_hostile = 0;
    gs->special_prompt_active = 0;
    log_action(gs, "GAME_EVENT", "One prisoner speaks: 'We're tired of this brig... Answer our riddles three!'");
    gs->current_riddle_idx = 0;
    log_action(gs, "RIDDLE", "Riddle 1: I have a spine, but no bones. I tell tales of distant zones. What am I?");
    log_action(gs, "PROMPT", "Your answer? > ");
    gs->special_prompt_active = 1;
    strcpy(gs->special_prompt_context, "RIDDLE_ANSWER_1");
}

void handle_use_diary(GameState* gs) {
    if (!player_has_item(&gs->player, ITEM_DIARY)) {
        log_action(gs, "GAME_ERROR", "You don't have the diary."); return;
    }
    if (gs->diary_deciphered) {
        log_action(gs, "GAME_INFO", "You've already read the important parts. It mentioned 'Esmeralda' and the code 'ESMERALDA'."); return;
    }
    if (player_has_item(&gs->player, ITEM_MYSTIC_LENS)) {
        log_action(gs, "GAME_EVENT", "You hold the Mystic Lens over the diary. The strange symbols resolve into clear text!");
        log_action(gs, "GAME_EVENT", "Diary: 'My heart's true north, her name the key... What is her name?'");
        log_action(gs, "PROMPT", "Enter her name: > ");
        gs->special_prompt_active = 1;
        strcpy(gs->special_prompt_context, "DIARY_RIDDLE_ANSWER");
    } else {
        display_ascii_art("JUMBLED_DIARY");
        log_action(gs, "GAME_INFO", "You might need something special to decipher it.");
    }
}

void handle_use_treasurekey(GameState* gs) {
    if (!player_has_item(&gs->player, ITEM_TREASURE_KEY)) {
        log_action(gs, "GAME_ERROR", "You don't have the treasure key."); return;
    }
    if (gs->player.current_room_id == ROOM_CAPTAIN_QUARTERS && game_rooms[ROOM_CAPTAIN_QUARTERS].exits[0] == ROOM_TREASURE_ROOM) {
        log_action(gs, "GAME_EVENT", "You try the Treasure Key on the locked door to the north... it seems like it would fit!");
        log_action(gs, "GAME_INFO", "(Try going north to use it automatically)");
    } else {
        log_action(gs, "GAME_INFO", "There's nothing here to use the treasure key on.");
    }
}

// Main 'use' dispatcher
void handle_use(GameState* gs, const char* item_name_str) {
    if (!item_name_str) { log_action(gs, "GAME_ERROR", "Use what?"); return; }

    if (strcasecmp(item_name_str, "cook") == 0) handle_use_cook(gs);
    else if (strcasecmp(item_name_str, "sword") == 0) {
        if (gs->special_prompt_active && strcmp(gs->special_prompt_context, "PRISONER_ATTACK") == 0 && gs->player.current_room_id == ROOM_PRISON_HOLD) {
            handle_use_sword_for_prisoners(gs);
        } else {
            log_action(gs, "GAME_INFO", "You swing your sword around. Impressive, but not very useful right now.");
        }
    }
    else if (strcasecmp(item_name_str, "diary") == 0) handle_use_diary(gs);
    else if (strcasecmp(item_name_str, "lens") == 0) {
        if (player_has_item(&gs->player, ITEM_DIARY) && player_has_item(&gs->player, ITEM_MYSTIC_LENS)) {
            handle_use_diary(gs); // Using lens on diary
        } else if (player_has_item(&gs->player, ITEM_MYSTIC_LENS)) {
            log_action(gs, "GAME_INFO", "You look through the lens. The world looks... shimmery.");
        } else {
            log_action(gs, "GAME_ERROR", "You don't have a lens to use.");
        }
    }
    else if (strcasecmp(item_name_str, "treasurekey") == 0) handle_use_treasurekey(gs);
    else if (strcasecmp(item_name_str, "portrait") == 0) {
         log_action(gs, "GAME_INFO", "You try to 'use' the portrait, but it just hangs there, staring sternly.");
    }
    else {
        char buffer[MAX_LINE_LENGTH];
        sprintf(buffer, "You can't use '%s' that way or it does nothing here.", item_name_str);
        log_action(gs, "GAME_ERROR", buffer);
    }
}

void handle_open_chest(GameState* gs) {
    if (gs->player.current_room_id != ROOM_CAPTAIN_QUARTERS) {
        log_action(gs, "GAME_ERROR", "There is no chest here to open."); return;
    }
    if (gs->chest_unlocked) {
        char chest_msg[MAX_LINE_LENGTH] = "The chest is already open. ";
        if (!player_has_item(&gs->player, ITEM_TREASURE_KEY) && item_in_room(&game_rooms[ROOM_CAPTAIN_QUARTERS], ITEM_TREASURE_KEY)){
            strcat(chest_msg, "You see the [TreasureKey] inside.");
        } else if (player_has_item(&gs->player, ITEM_TREASURE_KEY)){
            strcat(chest_msg, "You already took the key.");
        } else {
             strcat(chest_msg, "It's empty now."); // Should not happen if key is only item
        }
        log_action(gs, "GAME_INFO", chest_msg);
        return;
    }
    if (!gs->knows_chest_code) {
        log_action(gs, "GAME_INFO", "The chest has a combination lock. You don't know the code."); return;
    }
    log_action(gs, "PROMPT", "The chest has a combination lock. Enter the code: > ");
    gs->special_prompt_active = 1;
    strcpy(gs->special_prompt_context, "CHEST_CODE_ENTRY");
}


// --- Special Input Processing ---
void process_special_input(GameState* gs, const char* raw_input) {
    char input[MAX_LINE_LENGTH];
    strncpy(input, raw_input, MAX_LINE_LENGTH -1);
    input[MAX_LINE_LENGTH-1] = '\0';
    to_lower_str(input); // Processed input is lowercase

    if (strcmp(gs->special_prompt_context, "PRISONER_ATTACK") == 0) {
        // "use sword" is handled by the main command parser now, this is fallback
        if (!(strncmp(input, "use sword", 9) == 0)) { // Check if command starts with "use sword"
             log_action(gs, "GAME_EVENT", "You hesitate or do the wrong thing!");
             handle_game_over(gs, "Without a weapon to defend yourself, the prisoners overwhelm you.", "GAME_OVER_PRISONERS");
        }
         // If "use sword" was typed, it would be handled by `handle_use` which clears special prompt.
         // If it wasn't, and we are still in special prompt, it means something else was typed.
    }
    else if (strncmp(gs->special_prompt_context, "RIDDLE_ANSWER_", strlen("RIDDLE_ANSWER_")) == 0) {
        int riddle_num = gs->current_riddle_idx;
        const char* answers_r1[] = {"book", "logbook", NULL};
        const char* answers_r2[] = {"horizon", NULL};
        const char* answers_r3[] = {"bottle", NULL};
        const char** current_answers = NULL;

        if (riddle_num == 0) current_answers = answers_r1;
        else if (riddle_num == 1) current_answers = answers_r2;
        else if (riddle_num == 2) current_answers = answers_r3;

        int correct = 0;
        if(current_answers) {
            for(int i=0; current_answers[i] != NULL; ++i) {
                if (strcmp(input, current_answers[i]) == 0) {
                    correct = 1;
                    break;
                }
            }
        }

        if (correct) {
            log_action(gs, "GAME_EVENT", "Correct!");
            gs->current_riddle_idx++;
            if (gs->current_riddle_idx >= 3) {
                log_action(gs, "GAME_EVENT", "Impressive! You've got a sharp mind. They give you a [Mystic Lens].");
                add_item_to_inventory(&gs->player, ITEM_MYSTIC_LENS);
                log_action(gs, "GAME_EVENT", "Prisoner: 'We heard the Captain scribbling in his diary... something about a secret.'");
                gs->special_prompt_active = 0;
            } else {
                if (gs->current_riddle_idx == 1) log_action(gs, "RIDDLE", "Riddle 2: I am always coming, but never arrive... What am I?");
                else if (gs->current_riddle_idx == 2) log_action(gs, "RIDDLE", "Riddle 3: What has a neck without a head... What am I?");
                log_action(gs, "PROMPT", "Your answer? > ");
                sprintf(gs->special_prompt_context, "RIDDLE_ANSWER_%d", gs->current_riddle_idx + 1);
            }
        } else {
            gs->riddle_attempts[riddle_num]--;
            if (gs->riddle_attempts[riddle_num] > 0) {
                char buffer[MAX_LINE_LENGTH];
                sprintf(buffer, "Nay, that's not it. Try again. (%d attempts left for this riddle)", gs->riddle_attempts[riddle_num]);
                log_action(gs, "GAME_EVENT", buffer);
                log_action(gs, "PROMPT", "Your answer? > ");
            } else {
                log_action(gs, "GAME_EVENT", "You've exhausted their patience with your foolish guesses!");
                handle_game_over(gs, "The prisoners lose their temper and attack.", "GAME_OVER_PRISONERS");
                gs->special_prompt_active = 0;
            }
        }
    }
    else if (strcmp(gs->special_prompt_context, "DIARY_RIDDLE_ANSWER") == 0) {
        if (strcmp(input, "esmeralda") == 0) {
            log_action(gs, "GAME_EVENT", "Correct! The diary pages shimmer: 'The code to my chest is her name: ESMERALDA'.");
            gs->diary_deciphered = 1;
            gs->knows_chest_code = 1;
            gs->special_prompt_active = 0;
        } else {
            log_action(gs, "GAME_EVENT", "That name doesn't seem right. The diary remains cryptic.");
            gs->special_prompt_active = 0;
        }
    }
    else if (strcmp(gs->special_prompt_context, "CHEST_CODE_ENTRY") == 0) {
        if (strcmp(input, "esmeralda") == 0) {
            log_action(gs, "GAME_EVENT", "CLICK! The lock springs open. Inside is a gleaming [TreasureKey]!");
            gs->chest_unlocked = 1;
            add_item_to_room(&game_rooms[ROOM_CAPTAIN_QUARTERS], ITEM_TREASURE_KEY);
            gs->special_prompt_active = 0;
        } else {
            log_action(gs, "GAME_EVENT", "The lock remains stubbornly shut.");
            gs->special_prompt_active = 0;
        }
    }
    else if (strcmp(gs->special_prompt_context, "INTRO_CONTINUE") == 0) {
        if (strcmp(input, "continue") == 0) {
            log_action(gs, "ACTION", "You decide to board the galleon...");
            run_animation(ANIMATION_FILENAME, gs); // ANIMATION_FILENAME is from animation.h
            gs->player.current_room_id = ROOM_DECK;
            show_room_description(gs);
            gs->special_prompt_active = 0;
        } else {
            log_action(gs, "GAME_INFO", "Type 'continue' to start your adventure.");
            log_action(gs, "PROMPT", "> ");
        }
    }
}

void restart_game_flow(GameState* gs) {
    log_action(gs, "SYSTEM", "Restarting game / Starting new game...");
    init_game_state(gs); // Resets flags, player pos, inventory, room items etc.
    
    CLEAR_SCREEN();

    // Display the initial welcome and help message
    // Note: gs->log_file might not be open yet if this is the very first start
    // and log_action tries to use it. display_help_message handles gs being NULL.
    // However, in our main.c, log_file is opened before the first call to restart_game_flow.
    display_help_message(gs); // Show how to play

    // Then, the story intro
    log_action(gs, "STORY", "You are adrift in a small, rickety boat... A towering pirate galleon looms nearby. This might be your only chance...");
    log_action(gs, "PROMPT", "Type 'continue' to board the ship. > ");
    gs->special_prompt_active = 1;
    strcpy(gs->special_prompt_context, "INTRO_CONTINUE");
}

=== ./animation.c ===
#include "animation.h"
#include "utils.h" // For log_action (needs full GameState)
#include "game_state.h" // For full GameState for log_action

int run_animation(const char *filename, GameState* gs) {
    FILE *fp = fopen(filename, "r");
    if (!fp) {
        log_action(gs, "SYSTEM_ERROR", "Failed to open animation file.");
        perror("fopen animation");
        return 1; // Error
    }

    char line[MAX_LINE_LENGTH];
    char frame_buffer[MAX_FRAME_LINES * MAX_LINE_LENGTH] = {0};
    float delay_seconds;

    if (!fgets(line, sizeof(line), fp)) { fclose(fp); return 1; } // Read delay
    delay_seconds = atof(line);

    // Skip header lines (assuming 3 lines after delay)
    for(int i=0; i<3; ++i) {
        if (!fgets(line, sizeof(line), fp)) { fclose(fp); return 1; }
    }
    
    while (fgets(line, sizeof(line), fp)) {
        line[strcspn(line, "\n")] = 0; // Remove newline

        if (strcmp(line, FRAME_DELIMITER) == 0) {
            CLEAR_SCREEN();
            printf("%s\n", frame_buffer);
            fflush(stdout);
            SLEEP_MS((int)(delay_seconds * 1000));
            frame_buffer[0] = '\0'; // Clear buffer
        } else {
            strcat(frame_buffer, line);
            strcat(frame_buffer, "\n");
        }
    }
    
    fclose(fp);
    // Last frame might be important, so don't clear screen here without thought
    return 0; // Success
}

=== ./utils.c ===
#include "utils.h"
#include "game_state.h" // Needs full GameState definition for gs->log_file

void log_action(GameState* gs, const char* action_type, const char* message) {
    time_t now = time(NULL);
    char time_str[30];
    strftime(time_str, sizeof(time_str), "%Y-%m-%d %H:%M:%S", localtime(&now));

    if (gs->log_file) {
        fprintf(gs->log_file, "[%s] %s: %s\n", time_str, action_type, message);
        fflush(gs->log_file);
    }
    printf("%s\n", message); // Also print to console for immediate feedback
}

void print_to_console(const char* message) {
    printf("%s\n", message);
}

void to_lower_str(char* str) {
    if (!str) return;
    for (int i = 0; str[i]; i++) {
        str[i] = tolower((unsigned char)str[i]);
    }
}

void display_ascii_art(const char* art_name) {
    if (strcmp(art_name, "GAME_OVER_COOK") == 0) {
        print_to_console("\n   _____          __  __ ______    ______      ________ _____  \n  / ____|   /\\   |  \\/  |  ____|  / __ \\ \\    / /  ____|  __ \\ \n | |  __   /  \\  | \\  / | |__    | |  | \\ \\  / /| |__  | |__) |\n | | |_ | / /\\ \\ | |\\/| |  __|   | |  | |\\ \\/ / |  __| |  _  / \n | |__| |/ ____ \\| |  | | |____  | |__| | \\  /  | |____| | \\ \\ \n  \\_____/_/    \\_\\_|  |_|______|  \\____/   \\/   |______|_|  \\_\\\n");
        print_to_console("The Cook didn't appreciate your offering. You've been skewered!");
    } else if (strcmp(art_name, "GAME_OVER_CAPTAIN") == 0) {
        print_to_console("\n   _____          __  __ ______    ______      ________ _____  \n  / ____|   /\\   |  \\/  |  ____|  / __ \\ \\    / /  ____|  __ \\ \n | |  __   /  \\  | \\  / | |__    | |  | \\ \\  / /| |__  | |__) |\n | | |_ | / /\\ \\ | |\\/| |  __|   | |  | |\\ \\/ / |  __| |  _  / \n | |__| |/ ____ \\| |  | | |____  | |__| | \\  /  | |____| | \\ \\ \n  \\_____/_/    \\_\\_|  |_|______|  \\____/   \\/   |______|_|  \\_\\\n");
        print_to_console("The Captain was not pleased to be woken by a squawking parrot! BANG!");
    } else if (strcmp(art_name, "GAME_OVER_PRISONERS") == 0) {
        print_to_console("\n   _____          __  __ ______    ______      ________ _____  \n  / ____|   /\\   |  \\/  |  ____|  / __ \\ \\    / /  ____|  __ \\ \n | |  __   /  \\  | \\  / | |__    | |  | \\ \\  / /| |__  | |__) |\n | | |_ | / /\\ \\ | |\\/| |  __|   | |  | |\\ \\/ / |  __| |  _  / \n | |__| |/ ____ \\| |  | | |____  | |__| | \\  /  | |____| | \\ \\ \n  \\_____/_/    \\_\\_|  |_|______|  \\____/   \\/   |______|_|  \\_\\\n");
        print_to_console("The prisoners were not impressed. You've met a sticky end.");
    } else if (strcmp(art_name, "WIN_GAME") == 0) {
        print_to_console("\n__   __            _    _ _       _ \n\\ \\ / /           | |  | (_)     | |\n \\ V /___  _   _  | |  | |_ _ __ | |\n  \\ // _ \\| | | | | |/\\| | | '_ \\| |\n  | | (_) | |_| | \\  /\\  / | | | |_|\n  \\_/\\___/ \\__,_|  \\/  \\/|_|_| |_(_)\n");
        print_to_console("Congratulations! You have plundered the pirate's loot and won the game!");
    } else if (strcmp(art_name, "JUMBLED_DIARY") == 0) {
        print_to_console("~@#$%^&*()_+|}{P ريال OIUYTREWQASDFGHJKL:NBVCXZ`1234567890-=");
        print_to_console("The script is a swirling, unreadable mess of arcane symbols.");
    }
}

void display_help_message(GameState* gs) {
    const char* help_text =
        "----------------------------------------------------------------------\n"
        "Welcome to The Buccaneer's Cipher!\n"
        "Your goal is to explore the pirate ship, solve puzzles, and find the treasure.\n"
        "\n"
        "HOW TO PLAY:\n"
        " - Type commands and press Enter.\n"
        " - Commands are usually 1 or 2 words (e.g., 'look', 'pick up sword').\n"
        " - Pay attention to item names in room descriptions, often shown in [brackets].\n"
        "\n"
        "BASIC COMMANDS:\n"
        "  Movement:\n"
        "    north (or n)     - Move north\n"
        "    south (or s)     - Move south\n"
        "    east (or e)      - Move east\n"
        "    west (or w)      - Move west\n"
        "  Interaction:\n"
        "    look             - Describe your current room and visible items/exits.\n"
        "    look at [item]   - Examine an item more closely (e.g., 'look at sword').\n"
        "    examine [item]   - Same as 'look at [item]'.\n"
        "    pick up [item]   - Add an item to your inventory (e.g., 'pick up key').\n"
        "    take [item]      - Same as 'pick up [item]'.\n"
        "    drop [item]      - Remove an item from inventory and place it in the room.\n"
        "    inventory (or i) - Show what items you are carrying.\n"
        "    use [item]       - Use an item, sometimes on another object or character\n"
        "                       (e.g., 'use key', 'use cook', 'use diary').\n"
        "    open [item]      - Try to open something (e.g., 'open chest').\n"
        "  Game:\n"
        "    help             - Display this help message again.\n"
        "    quit             - Exit the game.\n"
        "----------------------------------------------------------------------";

    // Log that help was displayed, but print the raw text for better formatting.
    if (gs) { // gs might be NULL if called before game state is fully ready for logging
        log_action(gs, "INFO", "Help message displayed to player.");
    }
    printf("%s\n", help_text);
}

=== ./main.c ===
#include "common.h"
#include "item.h"
#include "room.h"
#include "player.h" // Not directly used in main, but good to show gs includes it
#include "game_state.h"
#include "utils.h"
#include "parser.h"
#include "game_logic.h"
// animation.h is included via game_logic.h for restart_game_flow

int main() {
    GameState gs;
    char input_buffer[MAX_LINE_LENGTH];
    char* command;
    char* argument;

    // Initialize game components
    init_items();
    // init_rooms(); // This is called within init_game_state now
    // init_game_state(&gs); // This is called by restart_game_flow

    gs.log_file = fopen(LOG_FILENAME, "a"); // Open log file in append mode
    if (!gs.log_file) {
        perror("Error opening log file");
        // Game can proceed without logging, but good to note
        // return 1; // Or allow game to run without log
    }
    log_action(&gs, "SYSTEM", "Game client started.");

    restart_game_flow(&gs); // Sets up initial game state and intro

    while (!gs.game_won) {
        if (gs.game_over) {
            if (gs.should_restart) { // Check if restart is pending
                log_action(&gs, "PROMPT", "Game Over. Play again? (yes/no) > ");
                if (fgets(input_buffer, sizeof(input_buffer), stdin)) {
                    char temp_input[MAX_LINE_LENGTH]; // for logging raw input
                    strncpy(temp_input, input_buffer, MAX_LINE_LENGTH -1);
                    temp_input[MAX_LINE_LENGTH-1] = '\0';
                    temp_input[strcspn(temp_input, "\n")] = 0;
                    log_action(&gs, "PLAYER_CMD (RESTART?)", temp_input);

                    to_lower_str(input_buffer); // process for "yes"/"no"
                    input_buffer[strcspn(input_buffer, "\n")] = 0;

                    if (strcmp(input_buffer, "yes") == 0) {
                        restart_game_flow(&gs);
                        // game_over will be reset by init_game_state via restart_game_flow
                        // should_restart will also be reset
                        continue; // Back to the game loop start
                    } else {
                        log_action(&gs, "SYSTEM", "Thanks for playing!");
                        break; // Exit while loop, end game
                    }
                } else { // EOF or error
                    log_action(&gs, "SYSTEM", "Input error during restart prompt. Exiting.");
                    break;
                }
            } else { // game_over is true, but not prompting for restart (should not happen with current logic)
                 break; // Safety break
            }
        }

        if (!gs.special_prompt_active) {
            printf("\nWhat do you do? > "); // Raw printf for prompt to avoid logging it repeatedly as "INFO"
            // log_action(&gs, "PROMPT", "\nWhat do you do? > "); // Avoids double print if log_action also prints
        }
        // Special prompts are printed by the functions that set them.

        if (fgets(input_buffer, sizeof(input_buffer), stdin) == NULL) {
            log_action(&gs, "SYSTEM_ERROR", "Error reading input or EOF reached. Exiting.");
            break; 
        }
        
        char logged_input[MAX_LINE_LENGTH]; 
        strncpy(logged_input, input_buffer, MAX_LINE_LENGTH-1);
        logged_input[MAX_LINE_LENGTH-1] = '\0';
        logged_input[strcspn(logged_input, "\n")] = 0; 

        if (gs.special_prompt_active) {
            log_action(&gs, "PLAYER_CMD (SPECIAL)", logged_input);
            process_special_input(&gs, logged_input);
        } else {
            log_action(&gs, "PLAYER_CMD", logged_input);
            char temp_parse_buffer[MAX_LINE_LENGTH]; // strtok modifies string, so pass a copy
            strncpy(temp_parse_buffer, input_buffer, MAX_LINE_LENGTH);
            temp_parse_buffer[MAX_LINE_LENGTH-1] = '\0';

            parse_input(temp_parse_buffer, &command, &argument);

            if (command == NULL || strlen(command) == 0) { // Empty input
                continue;
            }

            if (strcmp(command, "quit") == 0) {
                log_action(&gs, "SYSTEM", "Quitting game.");
                break;
            } else if (strcmp(command, "north") == 0 || strcmp(command, "n") == 0) {
                handle_move(&gs, "north");
            } else if (strcmp(command, "south") == 0 || strcmp(command, "s") == 0) {
                handle_move(&gs, "south");
            } else if (strcmp(command, "east") == 0 || strcmp(command, "e") == 0) {
                handle_move(&gs, "east");
            } else if (strcmp(command, "west") == 0 || strcmp(command, "w") == 0) {
                handle_move(&gs, "west");
            } else if (strcmp(command, "look") == 0) { // "look" or "look <item>"
                 if (argument == NULL) handle_examine(&gs, NULL); // look around
                 else handle_examine(&gs, argument); // "look <item>" -> examine <item>
            } else if (strcmp(command, "examine") == 0) {
                 if (!argument) log_action(&gs, "GAME_ERROR", "Examine what?");
                 else handle_examine(&gs, argument);
            } else if (strcmp(command, "pickup") == 0) { // "pickup <item>" or "take <item>"
                handle_pickup(&gs, argument);
            } else if (strcmp(command, "drop") == 0) {
                handle_drop(&gs, argument);
            } else if (strcmp(command, "inventory") == 0 || strcmp(command, "i") == 0) {
                handle_inventory(&gs);
            } else if (strcmp(command, "use") == 0) {
                handle_use(&gs, argument);
            } else if (strcmp(command, "open") == 0 && argument && strcmp(argument, "chest") == 0) {
                handle_open_chest(&gs);
            } else if (strcmp(command, "help") == 0) {
                display_help_message(&gs); // Call the comprehensive help display
            }
            else {
                char err_buf[MAX_LINE_LENGTH];
                sprintf(err_buf, "Unknown command: '%s'", command ? command : "(empty)");
                log_action(&gs, "GAME_ERROR", err_buf);
            }
        }
    }

    if (gs.game_won) {
        log_action(&gs, "SYSTEM", "Congratulations on winning!");
    }
    log_action(&gs, "SYSTEM", "Game client ended.");
    if (gs.log_file) {
        fclose(gs.log_file);
    }

    return 0;
}

=== ./room.c ===
#include "room.h"
#include <stdio.h> // For NULL

// Define the global rooms array
Room game_rooms[NUM_ROOMS];

void add_item_to_room(Room* room, ItemID item_id) {
    if (room->item_count < MAX_ROOM_ITEMS) {
        room->items_in_room[room->item_count++] = item_id;
    }
    // Else: could add an error message if room is full
}

void remove_item_from_room(Room* room, ItemID item_id) {
    int found_idx = -1;
    for (int i = 0; i < room->item_count; ++i) {
        if (room->items_in_room[i] == item_id) {
            found_idx = i;
            break;
        }
    }

    if (found_idx != -1) {
        // Shift items down to fill the gap
        for (int i = found_idx; i < room->item_count - 1; ++i) {
            room->items_in_room[i] = room->items_in_room[i + 1];
        }
        room->item_count--;
    }
}

// Definition for item_in_room
int item_in_room(Room* room, ItemID item_id) {
    for (int i = 0; i < room->item_count; ++i) {
        if (room->items_in_room[i] == item_id) {
            return 1; // True, item is in room
        }
    }
    return 0; // False, item is not in room
}


void init_rooms(void) {
    // ROOM_DECK
    game_rooms[ROOM_DECK] = (Room){ROOM_DECK, "Pirate Ship Deck",
        "You are on the weathered deck of the pirate ship. Salt spray mists the air. You see a weathered mast, coiled ropes, and a door leading further into the ship.",
        {NUM_ROOMS, NUM_ROOMS, ROOM_GALLEY, NUM_ROOMS}, // N, S, E, W (NUM_ROOMS means no exit)
        {ITEM_NONE}, 0, 0
    };
    add_item_to_room(&game_rooms[ROOM_DECK], ITEM_SWORD);
    add_item_to_room(&game_rooms[ROOM_DECK], ITEM_PARROT);
    add_item_to_room(&game_rooms[ROOM_DECK], ITEM_PORTRAIT);

    // ROOM_GALLEY
    game_rooms[ROOM_GALLEY] = (Room){ROOM_GALLEY, "The Galley",
        "The cramped galley smells of stale food and rum. A grumpy-looking Cook stirs a bubbling pot. There's a door to the south leading to a cold storage area, and another door north.",
        {ROOM_CAPTAIN_QUARTERS, ROOM_FRIDGE, NUM_ROOMS, ROOM_DECK},
        {ITEM_NONE}, 0, 0
    };

    // ROOM_FRIDGE
    game_rooms[ROOM_FRIDGE] = (Room){ROOM_FRIDGE, "Fridge Room (Pantry)",
        "A chilly room, lined with shelves. Various foodstuffs are stored here.",
        {ROOM_GALLEY, NUM_ROOMS, NUM_ROOMS, NUM_ROOMS},
        {ITEM_NONE}, 0, 0
    };
    add_item_to_room(&game_rooms[ROOM_FRIDGE], ITEM_SALTED_PORK);
    add_item_to_room(&game_rooms[ROOM_FRIDGE], ITEM_HARDTACK_BISCUITS);
    add_item_to_room(&game_rooms[ROOM_FRIDGE], ITEM_GROG_BOTTLE);
    add_item_to_room(&game_rooms[ROOM_FRIDGE], ITEM_ROTTEN_FISH);

    // ROOM_CAPTAIN_QUARTERS
    game_rooms[ROOM_CAPTAIN_QUARTERS] = (Room){ROOM_CAPTAIN_QUARTERS, "Captain's Quarters",
        "A lavishly decorated cabin. A large Captain figure lies snoring on a rug. A grand desk holds a leather-bound [Diary]. A sturdy [Chest] sits in the corner. There's a barred door to the east.",
        {ROOM_TREASURE_ROOM, ROOM_GALLEY, ROOM_PRISON_HOLD, NUM_ROOMS},
        {ITEM_NONE}, 0, 0
    };
    add_item_to_room(&game_rooms[ROOM_CAPTAIN_QUARTERS], ITEM_DIARY);

    // ROOM_PRISON_HOLD
    game_rooms[ROOM_PRISON_HOLD] = (Room){ROOM_PRISON_HOLD, "Prison Hold",
        "A dark, damp hold. Three shadowy Prisoners look agitated.",
        {NUM_ROOMS, NUM_ROOMS, NUM_ROOMS, ROOM_CAPTAIN_QUARTERS},
        {ITEM_NONE}, 0, 0
    };

    // ROOM_TREASURE_ROOM
    game_rooms[ROOM_TREASURE_ROOM] = (Room){ROOM_TREASURE_ROOM, "Treasure Room",
        "Piles of gold coins, chests overflowing with jewels, ancient artifacts, and all manner of glittering plunder fill the room!",
        {NUM_ROOMS, NUM_ROOMS, NUM_ROOMS, NUM_ROOMS},
        {ITEM_NONE}, 0, 0
    };
}

=== ./item.c ===
#include "item.h"
#include <string.h> // For strcasecmp
#include <stdio.h>  // For NULL if not in common.h for some reason

// Define the global items array
Item game_items[MAX_ITEMS];

void init_items(void) {
    game_items[ITEM_SWORD] =             (Item){ITEM_SWORD, "sword", "A trusty pirate sword.", "A sharp, gleaming cutlass. Looks reliable.", 1};
    game_items[ITEM_PARROT] =            (Item){ITEM_PARROT, "parrot", "A colorful, noisy parrot.", "It keeps muttering 'Pieces of eight! Pieces of eight!'", 1};
    game_items[ITEM_PORTRAIT] =          (Item){ITEM_PORTRAIT, "portrait", "A gaudy portrait.", "A faded portrait of a stern-looking woman. A small plaque beneath reads 'Esmeralda, his guiding star.'", 0};
    game_items[ITEM_SALTED_PORK] =       (Item){ITEM_SALTED_PORK, "pork", "A slab of salted pork.", "Looks tough, but probably edible. Salted pork.", 1};
    game_items[ITEM_HARDTACK_BISCUITS] = (Item){ITEM_HARDTACK_BISCUITS, "biscuits", "Some hardtack biscuits.", "Rock-hard biscuits. Hardtack biscuits, a pirate staple.", 1};
    game_items[ITEM_GROG_BOTTLE] =       (Item){ITEM_GROG_BOTTLE, "grog", "A bottle of grog.", "A dark bottle filled with what smells like strong grog.", 1};
    game_items[ITEM_ROTTEN_FISH] =       (Item){ITEM_ROTTEN_FISH, "fish", "A rotten fish.", "Ugh, this fish smells terrible. Definitely rotten.", 1};
    game_items[ITEM_DIARY] =             (Item){ITEM_DIARY, "diary", "A leather-bound diary.", "A heavy, locked diary. It seems important.", 1};
    game_items[ITEM_MYSTIC_LENS] =       (Item){ITEM_MYSTIC_LENS, "lens", "A mystic lens.", "A peculiar lens that seems to shimmer with an inner light.", 1};
    game_items[ITEM_TREASURE_KEY] =      (Item){ITEM_TREASURE_KEY, "treasurekey", "A large ornate key.", "This must be the key to the treasure!", 1};
    game_items[ITEM_NONE] =              (Item){ITEM_NONE, "", "", "", 0}; // Sentinel
}

Item* get_item_by_name(const char* name) {
    if (name == NULL) return NULL;
    for (int i = 0; game_items[i].id != ITEM_NONE; ++i) {
        if (strcasecmp(game_items[i].name, name) == 0) {
            return &game_items[i];
        }
    }
    return NULL;
}

=== ./parser.c ===
#include "parser.h"
#include "utils.h" // For to_lower_str

#include <string.h> // For strtok, strcmp, strcspn
#include <stdio.h>  // For NULL

void parse_input(char* input, char** command, char** argument) {
    char* mutable_input = input; // Use a pointer to make it clear strtok modifies it.
    to_lower_str(mutable_input);
    mutable_input[strcspn(mutable_input, "\n")] = 0; // Remove newline

    *command = strtok(mutable_input, " \t\n");
    if (*command == NULL) {
        *argument = NULL;
        return;
    }

    // Handle "pick up" as a single "pickup" command
    if (strcmp(*command, "pick") == 0) {
        char* next_token = strtok(NULL, " \t\n");
        if (next_token != NULL && strcmp(next_token, "up") == 0) {
            *command = "pickup"; // Normalized command
            *argument = strtok(NULL, " \t\n");
        } else {
            *command = "pickup"; // Treat "pick sword" as "pickup sword"
            *argument = next_token;
        }
    } else if (strcmp(*command, "take") == 0) { // Also allow "take" as "pickup"
         *command = "pickup";
         *argument = strtok(NULL, " \t\n");
    }
    // Handle "look at" as "examine"
    else if (strcmp(*command, "look") == 0) {
        char* next_token = strtok(NULL, " \t\n");
        if (next_token != NULL && strcmp(next_token, "at") == 0) {
            *command = "examine"; // Normalize "look at" to "examine"
            *argument = strtok(NULL, " \t\n");
        } else {
            // If just "look", argument remains next_token (which could be NULL)
            // If "look <item>", command remains "look", argument is <item>
            // Game logic will handle "look" with NULL arg as "look around"
            // and "look <item>" will be re-routed to examine by game logic
            *argument = next_token;
        }
    }
    // For other commands that take one argument
    else if (strcmp(*command, "drop") == 0 ||
               strcmp(*command, "examine") == 0 ||
               strcmp(*command, "use") == 0 ||
               strcmp(*command, "open") == 0) {
        *argument = strtok(NULL, " \t\n");
    }
    // For commands that take no arguments (N, S, E, W, inventory, quit, help)
    else {
        *argument = NULL; // Ensure argument is NULL for these
    }
}

=== ./player.c ===
#include "player.h"
#include <stdio.h> // For NULL

void add_item_to_inventory(Player* player, ItemID item_id) {
    if (player->inventory_count < MAX_INVENTORY_ITEMS) {
        player->inventory[player->inventory_count++] = item_id;
    }
    // Else: could add error for full inventory
}

void remove_item_from_inventory(Player* player, ItemID item_id) {
    int found_idx = -1;
    for (int i = 0; i < player->inventory_count; ++i) {
        if (player->inventory[i] == item_id) {
            found_idx = i;
            break;
        }
    }

    if (found_idx != -1) {
        for (int i = found_idx; i < player->inventory_count - 1; ++i) {
            player->inventory[i] = player->inventory[i + 1];
        }
        player->inventory_count--;
    }
}

int player_has_item(Player* player, ItemID item_id) {
    for (int i = 0; i < player->inventory_count; ++i) {
        if (player->inventory[i] == item_id) {
            return 1; // True
        }
    }
    return 0; // False
}

